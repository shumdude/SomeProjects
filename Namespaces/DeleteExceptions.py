"""
Текст задачи (ссылка: https://stepik.org/lesson/24463/step/7?unit=6771)

Вам дано описание наследования классов исключений в следующем формате.
<имя исключения 1> : <имя исключения 2> <имя исключения 3> ... <имя исключения k>
Это означает, что исключение 1 наследуется от исключения 2, исключения 3, и т. д.
Костя посмотрел код и указал Антону на то, что некоторые исключения можно не ловить,
так как ранее в коде будет пойман их предок. Но Антон не помнит какие исключения наследуются от каких.
Напишите программу, которая будет определять обработку каких исключений можно удалить из кода.
**понять, какие из исключений можно и не ловить, потому что мы уже ранее где-то поймали их предка**

В первой строке входных данных содержится целое число n - число классов исключений.
В следующих n строках содержится описание наследования классов.
В i-й строке указано от каких классов наследуется i-й класс.
Обратите внимание, что класс может ни от кого не наследоваться.
Гарантируется, что класс не наследуется сам от себя (прямо или косвенно),
что класс не наследуется явно от одного класса более одного раза.

В следующей строке содержится число m - количество обрабатываемых исключений.
Следующие m строк содержат имена исключений в том порядке, в каком они были написаны у Антона в коде.
Гарантируется, что никакое исключение не обрабатывается дважды.
"""

# В данной задаче я приравниваю слова "класс", "ошибка", "исключение" друг к другу.
descriptions_exceptions = {}  # словарь, где ключ - класс/ошибка/исключение, а значение - список его родителей
succession_of_exceptions = []  # список, в котором определяется порядок исключений в коде Антона
volume_descriptions = int(input())  # n - количество передаваемых в консоль описаний наследования классов/исключений
for n in range(volume_descriptions):
    i = input().split()
    descriptions_exceptions[i[0]] = []  # изначально у класс нет родителей
    if len(i) > 1:  # если они [родители] всё-таки задаются в консоль
        for element in i[2:]:
            descriptions_exceptions[i[0]].append(element)  # добавляем родителей в список
volume_succession = int(input())  # m - количество передаваемых в консоль исключений [в коде Антона]
for m in range(volume_succession):
    i = input()
    succession_of_exceptions.append(i)


def recursion_function(input_exception, const_exception):  # принимает родителя и искомую ошибку
    parents = descriptions_exceptions[input_exception]  # список родителей, от которых наследуется переданный родитель
    if input_exception in succession_of_exceptions:  # есть ли вообще переданный родитель в списке Антона
        if succession_of_exceptions.index(input_exception) < succession_of_exceptions.index(const_exception):
            # *в списке Антона*
            # если родитель стоит левее наследника, то всё нормально - можно не удалять элемент кода Антона
            return True
    if parents:  # если есть родители у ошибки
        for parent in parents:  # перебираем всех родителей
            if recursion_function(parent, const_exception):
                return True
            else:  # !такое условие нужно для того, чтобы функция, упёршаяся в стену, не возвращала None!
                continue


for element in succession_of_exceptions[1:]:  # перебираем элементы словаря наследований
    if recursion_function(element, element):  # обрабатываем ошибку
        print(element)
print(descriptions_exceptions)
print(succession_of_exceptions)

"""
Тест 1
10
1 : 2 3 4
2 : 5 3 6 7 8 9
5 : 8
3 : 4 9
10 : 7
4
6 : 3 4
7 : 6
8 : 10 4 6 7
9
10
6
9
4
5
10
1
3
2
8
7

Тест 2
6
10
11 : 10
12 : 11
20
13 : 11 20
21 : 20
6
20
13
10
11
21
12
"""